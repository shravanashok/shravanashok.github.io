<!DOCTYPE html>
<html>
<head>
	<title>HackerRank Technical Support Engineer</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
</head>
<body>

	<section>

	<div class="spacer"></div>
		<div class="container">
			<h3 class="primary">Question</h3>
			<p class="">
				<br>
				I've noticed a common issue in HackerRank challenges which I think could be improved. I think there is an unfortunate contrast between the problem statements, the test cases and the examples used in the editorials. <br><br>

It's very common for challenges to have a line of input which returns number N and then a line with N space-separated values, or a line with N and M in the input, followed by N lines of M space-separated values. <br><br>

However, in my experience across a very wide range of challenges...1. The number of space-separated values *always* matches the number promised by N or M. This means that users can ignore the initial input and just take *all* the values on the line.2. The code shown in the editorials - at least, all the ones I've checked so far - does exactly that. N or M is read in, but *not* used to limit how many values are taken from following lines. <br><br>

Here's the first 3 lines of DOSHI's editorial solution for "Find the second largest number" in the Python challenges:n = int(input())numb = input()lis = list(map(int, numb.split()))As you can see, he ignores N and just reads all the values in the next line.I realise that the practice challenges don't expect users to perfectly validate input. <br><br>

I'm not sure that's a good idea. But I really don't think it's a good idea to tell users to read useless data *and* to show editorial examples which ignore that data. If users are told to read data, that data should mean something. <br><br>

So I think that Hackerrank should make one two changes to the way challenges are set up.1. Not have editorial examples which ignore input2. For a significant number of challenges which specify N, have input where the number of values is more than N, in a way that makes the code fail if it reads more than N values (e.g. average value, max/min value). <br><br>

I've never taken part in a Hackerrank competition, so I don't know what the policy on valid/invalid data is there. But I really think it is not good practice to encourage users to ignore the data that has been specified.1. Editorial code should not ignore input data2. A significant number of tests which specifies the number of values to read in should have at least one test case where the number of values is more than N, in a way which will cause the solution to fail if the solution code reads more than values. <br><br>
			</p>
		</div>
		<div class="container">
			<h3 class="success">Answer</h3>
			<p class="lead">
				
					<p>
						Hi, <br><br>Thanks for the detailed feedback. <br><br> We reviewed your feedback and agree with your comment. <br><br>

We ensure we share the value of N (array size) & the space separated array so that it is easy to read the input array across multiple languages. <br><br>

For example, consider the example of reading an integer array. We give the input in the following format. <br><br>

5<br>
1 2 3 4 5<br><br>

The easiest and the right way to read this input using C/C++ <br><br>

//Untested code below. May not even compile.
<br><br>int n, a[5];<br>
cin >> n;<br>
for (int i=0; i<n; i++) { 
  cin >> a[i];
<br>
} <br>

<br>But in languages like C#, where you have only Console.ReadLine(), the easiest way to read this input will be<br><br>

//Untested code below. May not even compile.<br><br>
int n = Convert.ToInt32(Console.ReadLine());<br>
string s = Console.ReadLine();<br>
string[] tokens = s.Split(' ');<br>
foreach (string token in tokens) {<br>
  a[i] = Console.ToInt32(token);<br>
}<br><br>

It gets even more complicated in Javascript, where the entire input is read as a single string. I hope you now get the idea why we provide redundant data. We want to make sure you have the best experience in solving the core of the problem and make it very easy for you to read the input. <br><br>

This is one more reason why we give perfectly valid data. We will never have the case where the number of elements in the line doesn’t match N. <br><br>For example, in "Find the second largest number”, we want you to spend all the time & energy in finding the second largest number (which is the core of this problem) and not in validating our input. That is not the objective of this problem. 

Once again, thank you for your feedback. Hope the above explanation makes things clear now. 
					</p>
				
		</div>
	</section>
</body>
</html>